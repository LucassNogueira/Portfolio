[
  {
    "id": 1,
    "title": "nuqs + React Hooks: Managing Modal State Without Losing Your Mind",
    "excerpt": "Managing modal state across components is painful. Learn how using nuqs and custom hooks makes it dead simple - no prop drilling, no context, just URL-based state that works everywhere.",
    "category": "React",
    "date": "Oct 11, 2024",
    "readTime": "6 min read",
    "slug": "nuqs-modal-state-hooks",
    "content": "# nuqs + React Hooks: Managing Modal State Without Losing Your Mind\n\nSo I was working on this feature at Veryable where we needed to open a confirmation modal from like 6 different places, and every time I needed to add another trigger point, I died a little inside. Prop drilling through 4-5 components, keeping track of which modal was open, what data it needed... it was getting ridiculous.\n\nThen someone on the team mentioned `nuqs` and honestly, it sounded weird at first. \"Put your modal state in the URL?\" But after trying it, I'm never going back.\n\n## The Problem (aka My Life Before nuqs)\n\nPicture this: You've got a user edit modal. You need to open it from:\n- The user list page\n- A detail view\n- Some random button in a sidebar\n- Oh, and now from a notification too\n\nSo you end up with this mess:\n\n```tsx\nconst [isEditModalOpen, setIsEditModalOpen] = useState(false);\nconst [editingUserId, setEditingUserId] = useState(null);\n\n// Pass these down through 47 components\n// Hope nobody refreshes the page\n// Die inside when product asks to add another trigger point\n```\n\nYeah. Not great.\n\n## What I Actually Did (nuqs + Custom Hooks)\n\nFirst, install nuqs:\n```bash\nnpm install nuqs\n```\n\nThe idea is simple - your modal state lives in the URL. So instead of `useState`, you use `nuqs` to manage query parameters. Here's what my actual hook looks like:\n\n```typescript\n// hooks/useUserEditModal.ts\nimport { parseAsBoolean, parseAsInteger, useQueryStates } from 'nuqs';\n\nexport const useUserEditModal = () => {\n  return useQueryStates({\n    editUserModal: parseAsBoolean.withDefault(false),\n    userId: parseAsInteger.withDefault(0)\n  });\n};\n```\n\nThat's literally it. Your URL becomes `?editUserModal=true&userId=123` and now you can read/write that state from anywhere.\n\n## Using It (This is Where It Gets Good)\n\nThe modal itself:\n\n```tsx\n// components/UserEditModal.tsx\n'use client';\n\nimport { useUserEditModal } from '@/hooks/useUserEditModal';\n\nexport const UserEditModal = () => {\n  const [{ editUserModal, userId }, setModalState] = useUserEditModal();\n  \n  const handleClose = () => {\n    setModalState({ editUserModal: false, userId: 0 });\n  };\n\n  if (!editUserModal) return null;\n\n  return (\n    <Modal open={editUserModal} onClose={handleClose}>\n      <div>Editing user {userId}</div>\n      <button onClick={handleClose}>Close</button>\n    </Modal>\n  );\n};\n```\n\nAnd then literally anywhere else in your app:\n\n```tsx\n// Could be in a totally different file, doesn't matter\nimport { useUserEditModal } from '@/hooks/useUserEditModal';\n\nexport const SomeRandomComponent = () => {\n  const [_, setModalState] = useUserEditModal();\n  \n  return (\n    <button onClick={() => setModalState({ editUserModal: true, userId: 123 })}>\n      Edit User\n    </button>\n  );\n};\n```\n\nNo prop drilling. No context. Just works.\n\n## The Stuff That Made Me Actually Like This\n\n**Deep linking just works**: Someone sends you `yourapp.com/dashboard?editUserModal=true&userId=42` and the modal pops right open. I didn't have to write any special code for this. Product manager sent me a URL with a bug in it, modal opened to the exact state, I fixed it. Felt like magic.\n\n**Browser back button**: Users can close modals by hitting back. Again, didn't write any code for this. It just works because the URL changes.\n\n**Multiple modals**: Just add more properties to your hook:\n\n```typescript\nexport const useAllMyModals = () => {\n  return useQueryStates({\n    editUser: parseAsBoolean.withDefault(false),\n    deleteUser: parseAsBoolean.withDefault(false),\n    userId: parseAsInteger.withDefault(0),\n    settingsOpen: parseAsBoolean.withDefault(false),\n    // whatever else you need\n  });\n};\n```\n\n## Things I Learned The Hard Way\n\n**Don't put everything in one hook**: I made this mistake. Had one giant `useAllModals()` hook and it got messy fast. Split them up by feature area.\n\n**Add helper functions to make life easier**:\n\n```typescript\nexport const useUserEditModal = () => {\n  const [state, setState] = useQueryStates({\n    editUserModal: parseAsBoolean.withDefault(false),\n    userId: parseAsInteger.withDefault(0)\n  });\n  \n  const openModal = (userId: number) => {\n    setState({ editUserModal: true, userId });\n  };\n  \n  const closeModal = () => {\n    setState({ editUserModal: false, userId: 0 });\n  };\n  \n  return { isOpen: state.editUserModal, userId: state.userId, openModal, closeModal };\n};\n```\n\nNow it's just:\n```tsx\nconst { openModal } = useUserEditModal();\n<button onClick={() => openModal(123)}>Edit</button>\n```\n\n**Server components don't work with this**: Learned this the hard way. You need `'use client'` at the top of any file using nuqs. It's a client-side thing because... well, URLs change on the client.\n\n**Don't put sensitive stuff in URLs**: I hope this is obvious but I'm saying it anyway. User IDs? Fine. Passwords or tokens? No.\n\n## Real Talk\n\nI was skeptical at first. \"Managing state in the URL sounds hacky\" is what I thought. But after using it for a few weeks, I can't imagine going back to the old way. \n\nNo more prop drilling through 5 components just to open a modal. No more \"wait, where did I define that state again?\" No more losing modal state on refresh and having users complain.\n\nThe URL is basically a global state store that's been there the whole time. We just forgot about it because we were too busy installing state management libraries.\n\nAnyway, try it out. Worst case, you spend 30 minutes and decide it's not for you. Best case, you never prop drill modal state again.\n\nWorth it.\n\n"
  },
  {
    "id": 2,
    "title": "Building Features Before the Backend Exists (makeMockApiCall)",
    "excerpt": "Stop waiting for backend APIs. Build complete features with realistic mock data, test all edge cases, and swap in the real API later. Here's the utility that changed my workflow.",
    "category": "Development",
    "date": "Oct 11, 2024",
    "readTime": "8 min read",
    "slug": "make-mock-api-call-utility",
    "content": "# Building Features Before the Backend Exists (makeMockApiCall)\n\nReal talk - waiting on backend APIs is the worst part of frontend development. You're ready to build something, you've got the designs, you know exactly what you need to do, and then... \"oh the API isn't ready yet, maybe next sprint?\"\n\nSo here's what I do now: I just build it anyway.\n\n## The Problem\n\nYou need to build a user dashboard. Backend says it'll be 2 weeks. What do you do?\n\nOption A: Wait 2 weeks, build nothing, feel unproductive  \nOption B: Build the whole thing with mock data, swap in the real API later\n\nI pick B every time now.\n\n## The Setup\n\nI have two utilities: `makeApiCall` (the real one) and `makeMockApiCall` (my development cheat code).\n\nHere's the real API wrapper - nothing fancy:\n\n```typescript\n// utils/makeApiCall.ts\nexport const makeApiCall = async <T>(\n  url: string,\n  options?: RequestInit\n): Promise<T> => {\n  const response = await fetch(url, {\n    headers: {\n      'Content-Type': 'application/json',\n      ...options?.headers\n    },\n    ...options\n  });\n\n  if (!response.ok) {\n    throw new Error(`API call failed: ${response.statusText}`);\n  }\n\n  return response.json();\n};\n```\n\n## The Mock Version (This is Where It Gets Good)\n\nStarted simple:\n\n```typescript\n// utils/makeMockApiCall.ts\nexport const makeMockApiCall = async <T>(data: T): Promise<T> => {\n  const randomDelay = Math.floor(Math.random() * 1000) + 500;\n  \n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve(data);\n    }, randomDelay);\n  });\n};\n```\n\nBut then I realized I could make it way more useful:\n\n```typescript\ninterface MockConfig {\n  delay?: number;\n  minDelay?: number;\n  maxDelay?: number;\n  shouldError?: boolean;\n  errorMessage?: string;\n  successRate?: number; // 0-100\n}\n\nexport const makeMockApiCall = async <T>(\n  data: T,\n  config: MockConfig = {}\n): Promise<T> => {\n  const {\n    delay,\n    minDelay = 500,\n    maxDelay = 2000,\n    shouldError = false,\n    errorMessage = 'Mock API call failed',\n    successRate = 100\n  } = config;\n\n  // Calculate delay\n  const actualDelay = delay !== undefined\n    ? delay\n    : Math.floor(Math.random() * (maxDelay - minDelay)) + minDelay;\n\n  // Wait (simulates network)\n  await new Promise(resolve => setTimeout(resolve, actualDelay));\n\n  // Maybe throw an error\n  const shouldSucceed = Math.random() * 100 < successRate;\n  if (shouldError || !shouldSucceed) {\n    throw new Error(errorMessage);\n  }\n\n  return data;\n};\n```\n\n## How I Actually Use This\n\nSay I'm building a user list. Backend's not ready. I just do this:\n\n```typescript\nconst fetchUsers = async () => {\n  const mockUsers = [\n    { id: 1, name: 'Lucas', email: 'lucas@example.com', role: 'admin' },\n    { id: 2, name: 'Sarah', email: 'sarah@example.com', role: 'user' },\n  ];\n\n  return makeMockApiCall(mockUsers, {\n    delay: 1000 // Realistic delay\n  });\n};\n```\n\nShip the feature, show it to the PM, everyone's happy. When the real API is ready, I just replace `makeMockApiCall` with the real `makeApiCall`. Takes like 2 minutes.\n\n## Testing Loading States\n\nWant to see how your skeleton screens look?\n\n```typescript\n// Slow response to see loading states\nconst users = await makeMockApiCall(mockData, { delay: 5000 });\n```\n\nWant to test error handling?\n\n```typescript\n// Always fails\ntry {\n  await makeMockApiCall(mockData, {\n    shouldError: true,\n    errorMessage: 'User not found'\n  });\n} catch (error) {\n  // Your error UI shows up\n}\n```\n\nWant to test flaky networks?\n\n```typescript\n// 30% chance of failure\nawait makeMockApiCall(mockData, {\n  successRate: 70,\n  minDelay: 1000,\n  maxDelay: 5000\n});\n```\n\n## Actual Component Example\n\n```typescript\n'use client';\n\nimport { useState, useEffect } from 'react';\nimport { makeMockApiCall } from '@/utils/makeMockApiCall';\n// When ready: import { makeApiCall } from '@/utils/makeApiCall';\n\nexport const UserList = () => {\n  const [users, setUsers] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    const loadUsers = async () => {\n      try {\n        setLoading(true);\n        \n        const mockUsers = [\n          { id: 1, name: 'Lucas' },\n          { id: 2, name: 'Sarah' }\n        ];\n        \n        // Using mock for now\n        const data = await makeMockApiCall(mockUsers, { delay: 1000 });\n        \n        // When API is ready, swap to this:\n        // const data = await makeApiCall('/api/users');\n        \n        setUsers(data);\n      } catch (err) {\n        setError('Failed to load users');\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    loadUsers();\n  }, []);\n\n  if (loading) return <div>Loading...</div>;\n  if (error) return <div>{error}</div>;\n\n  return (\n    <div>\n      {users.map(user => (\n        <div key={user.id}>{user.name}</div>\n      ))}\n    </div>\n  );\n};\n```\n\nWhen the API is ready, just swap out the mock call for the real one. Comment out the mock data, uncomment the real call, done.\n\n## Generating Mock Data\n\nI got tired of typing out mock data, so I made helpers:\n\n```typescript\nexport const generateMockUser = (overrides?) => ({\n  id: Math.floor(Math.random() * 1000),\n  name: `User ${Math.floor(Math.random() * 100)}`,\n  email: `user${Math.floor(Math.random() * 100)}@example.com`,\n  role: Math.random() > 0.5 ? 'admin' : 'user',\n  ...overrides\n});\n\nexport const generateMockUsers = (count: number) => {\n  return Array.from({ length: count }, () => generateMockUser());\n};\n\n// Usage\nconst users = generateMockUsers(50);\nawait makeMockApiCall(users, { delay: 1000 });\n```\n\n## Preset Configs for Common Scenarios\n\n```typescript\nexport const MOCK_PRESETS = {\n  fast: { delay: 100 },\n  slow: { delay: 3000 },\n  error: { shouldError: true, errorMessage: 'Network error' },\n  flaky: { successRate: 70, minDelay: 500, maxDelay: 3000 }\n};\n\n// Usage\nawait makeMockApiCall(data, MOCK_PRESETS.flaky);\n```\n\n## Why This Changed My Workflow\n\nBefore: Wait for backend, build feature in a rush when it's finally ready, find bugs, can't test edge cases easily.\n\nNow: Build feature immediately, test all scenarios (loading, errors, slow networks), backend catches up eventually, swap in real API, ship.\n\nI've built entire features and demoed them to stakeholders before the backend existed. They have no idea it's fake data. Then when the real API is ready, I just swap the function call. \n\nIt's honestly one of those things that seems obvious in hindsight but took me way too long to figure out.\n\n## A Few Gotchas\n\n**Don't forget to swap**: I've definitely shown a demo with mock data when I thought I was using real data. Always double-check which function you're calling.\n\n**Keep mocks updated**: When the API contract changes, update your mocks. Otherwise you'll have type mismatches.\n\n**Mock data can lie**: Your mock might work perfectly but the real API returns slightly different data. Always test with real APIs before shipping.\n\n**Performance differences**: Mock is fast. Real API might be slow. Don't be surprised when things get slower in production.\n\n## Wrapping Up\n\nHaving a good mock API setup is like having a superpower. Backend isn't ready? Doesn't matter. Want to test error states? Easy. Need to demo something? Done.\n\nIt's not complicated - you're just returning data wrapped in a promise. But the time it saves is insane.\n\nTry it on your next feature. Build with mocks, swap in the real API later. You'll wonder why you ever waited around doing nothing."
  },
  {
    "id": 3,
    "title": "Toast Notifications: Just Call It From Anywhere",
    "excerpt": "No context, no providers, no prop drilling. A toast notification utility you can import and call from anywhere in your app - components, hooks, utilities, or server actions.",
    "category": "React",
    "date": "Oct 11, 2024",
    "readTime": "9 min read",
    "slug": "toast-notifications-everywhere",
    "content": "# Toast Notifications: Just Call It From Anywhere\n\nI used to hate implementing toast notifications. Every project had some weird setup where you had to import a context, wrap your component, pass functions around... it was annoying.\n\nThen I figured out how to make a toast utility that you can literally just import and call from anywhere. No context, no providers, no prop drilling. Just `toast.success('it worked')` and you're done.\n\n## My Requirements Were Simple\n\n1. Call it from any component\n2. Call it from custom hooks\n3. Call it from utility functions\n4. Call it from server actions (Next.js thing)\n5. Don't make me think about it\n\n## The Setup\n\nUsing `sonner` because it's the best toast library and I'll fight anyone who disagrees. Also Material-UI for styling because that's what we use at work.\n\n```bash\nnpm install sonner @mui/material @mui/icons-material @emotion/react @emotion/styled\n```\n\n## The Base Component\n\nMade a custom snackbar with MUI styling:\n\n```typescript\n// components/toast/BaseSnackbar.tsx\n'use client';\n\nimport { SnackbarContent, Theme } from '@mui/material';\nimport {\n  CheckCircle as SuccessIcon,\n  Error as ErrorIcon,\n  Warning as WarningIcon,\n} from '@mui/icons-material';\nimport { toast as sonnerToast } from 'sonner';\n\ninterface ToastProps {\n  id: string | number;\n  title: string;\n  variant: 'success' | 'error' | 'warning';\n  icon?: React.ReactNode;\n  closeHandler?: () => void;\n  actionText?: string;\n  actionHandler?: () => void;\n}\n\nexport const BaseSnackbar = (props: ToastProps) => {\n  const getStyle = (theme: Theme) => {\n    switch (props.variant) {\n      case 'success':\n        return { backgroundColor: theme.palette.success.main, color: '#fff' };\n      case 'error':\n        return { backgroundColor: theme.palette.error.main, color: '#fff' };\n      case 'warning':\n        return { backgroundColor: theme.palette.warning.main, color: '#fff' };\n    }\n  };\n\n  const getIcon = () => {\n    if (props.icon) return props.icon;\n    switch (props.variant) {\n      case 'success': return <SuccessIcon />;\n      case 'error': return <ErrorIcon />;\n      case 'warning': return <WarningIcon />;\n    }\n  };\n\n  return (\n    <SnackbarContent\n      sx={theme => ({ fontWeight: 500, minWidth: 300, ...getStyle(theme) })}\n      message={\n        <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>\n          {getIcon()}\n          <span>{props.title}</span>\n        </div>\n      }\n      action={\n        <>\n          {props.actionText && (\n            <button\n              onClick={() => {\n                props.actionHandler?.();\n                sonnerToast.dismiss(props.id);\n              }}\n              style={{\n                background: 'none',\n                border: 'none',\n                color: 'white',\n                cursor: 'pointer',\n                fontWeight: 600\n              }}\n            >\n              {props.actionText}\n            </button>\n          )}\n          <button\n            onClick={() => {\n              sonnerToast.dismiss(props.id);\n              props.closeHandler?.();\n            }}\n            style={{\n              background: 'none',\n              border: 'none',\n              color: 'white',\n              cursor: 'pointer',\n              fontSize: '20px'\n            }}\n          >\n            âœ•\n          </button>\n        </>\n      }\n    />\n  );\n};\n```\n\n## The Magic Utility\n\nThis is the part that makes it work everywhere:\n\n```typescript\n// utils/toast.tsx\n'use client';\n\nimport { toast as sonnerToast } from 'sonner';\nimport { BaseSnackbar } from '@/components/toast/BaseSnackbar';\n\ninterface ToastOptions {\n  icon?: React.ReactNode;\n  closeHandler?: () => void;\n  actionText?: string;\n  actionHandler?: () => void;\n  position?: 'top-right' | 'top-center' | 'bottom-right' | 'bottom-center';\n}\n\nexport const toast = {\n  success: (message: string, options?: ToastOptions) =>\n    sonnerToast.custom(\n      id => <BaseSnackbar id={id} title={message} variant=\"success\" {...options} />,\n      { position: options?.position || 'bottom-center' }\n    ),\n\n  error: (message: string, options?: ToastOptions) =>\n    sonnerToast.custom(\n      id => <BaseSnackbar id={id} title={message} variant=\"error\" {...options} />,\n      { position: options?.position || 'bottom-center' }\n    ),\n\n  warning: (message: string, options?: ToastOptions) =>\n    sonnerToast.custom(\n      id => <BaseSnackbar id={id} title={message} variant=\"warning\" {...options} />,\n      { position: options?.position || 'bottom-center' }\n    )\n};\n```\n\n## Add It To Your App\n\n```typescript\n// app/layout.tsx\nimport { Toaster } from 'sonner';\n\nexport default function RootLayout({ children }) {\n  return (\n    <html>\n      <body>\n        {children}\n        <Toaster richColors />\n      </body>\n    </html>\n  );\n}\n```\n\n## Using It (The Easy Part)\n\nIn a component:\n\n```typescript\n'use client';\n\nimport { toast } from '@/utils/toast';\n\nexport const UserForm = () => {\n  const handleSubmit = async (data) => {\n    try {\n      await saveUser(data);\n      toast.success('User saved!');\n    } catch (error) {\n      toast.error('Failed to save user');\n    }\n  };\n\n  return <form onSubmit={handleSubmit}>...</form>;\n};\n```\n\nIn a custom hook:\n\n```typescript\nimport { toast } from '@/utils/toast';\n\nexport const useUserMutation = () => {\n  const mutation = useMutation({\n    mutationFn: saveUser,\n    onSuccess: () => toast.success('Saved!'),\n    onError: () => toast.error('Failed')\n  });\n\n  return mutation;\n};\n```\n\nIn a utility function:\n\n```typescript\nimport { toast } from '@/utils/toast';\n\nexport const deleteUser = async (id: number) => {\n  try {\n    await api.delete(`/users/${id}`);\n    toast.success('User deleted');\n  } catch (error) {\n    toast.error('Delete failed');\n  }\n};\n```\n\n## With Actions\n\nThis is where it gets fun. You can add action buttons:\n\n```typescript\ntoast.success('File uploaded!', {\n  actionText: 'View',\n  actionHandler: () => router.push('/files/123')\n});\n\ntoast.error('Connection lost', {\n  actionText: 'Retry',\n  actionHandler: async () => await retryConnection()\n});\n```\n\nI use this for undo actions all the time:\n\n```typescript\nconst handleDelete = async (id: number) => {\n  await deleteItem(id);\n  \n  toast.success('Item deleted', {\n    actionText: 'Undo',\n    actionHandler: async () => {\n      await restoreItem(id);\n      toast.success('Item restored!');\n    }\n  });\n};\n```\n\n## Different Positions\n\n```typescript\n// Less important stuff\ntoast.info('New message', { position: 'top-right' });\n\n// Important actions\ntoast.success('Payment processed'); // bottom-center by default\n```\n\n## Loading Toasts\n\nFor longer operations:\n\n```typescript\nconst handleUpload = async (file: File) => {\n  const toastId = toast.info('Uploading...');\n  \n  try {\n    await uploadFile(file);\n    sonnerToast.dismiss(toastId);\n    toast.success('Upload complete!');\n  } catch (error) {\n    sonnerToast.dismiss(toastId);\n    toast.error('Upload failed');\n  }\n};\n```\n\nOr use sonner's promise helper:\n\n```typescript\nimport { toast as sonnerToast } from 'sonner';\n\nawait sonnerToast.promise(\n  saveData(),\n  {\n    loading: 'Saving...',\n    success: 'Saved!',\n    error: 'Failed to save'\n  }\n);\n```\n\n## Real Example: Form Submission\n\n```typescript\nconst handleSubmit = async (formData) => {\n  try {\n    setLoading(true);\n    await submitForm(formData);\n    \n    toast.success('Form submitted!', {\n      actionText: 'View',\n      actionHandler: () => router.push('/submissions')\n    });\n    \n    reset();\n  } catch (error) {\n    toast.error(error.message || 'Something went wrong');\n  } finally {\n    setLoading(false);\n  }\n};\n```\n\n## Domain-Specific Toasts\n\nI make these for common operations:\n\n```typescript\n// utils/userToasts.ts\nimport { toast } from './toast';\n\nexport const userToasts = {\n  created: () => toast.success('User created'),\n  updated: () => toast.success('User updated'),\n  deleted: () => toast.success('User deleted'),\n  error: (action: string) => toast.error(`Failed to ${action} user`)\n};\n\n// Usage\nuserToasts.created();\n```\n\nSaves time when you're doing the same operations over and over.\n\n## What I Like About This\n\n**No setup per component**: Just import and call. No providers, no context, no nothing.\n\n**Works everywhere**: Components, hooks, utils, server actions - doesn't matter.\n\n**Type-safe**: TypeScript knows what options you can pass.\n\n**Customizable**: Want a custom icon? Position? Action button? All there.\n\n**MUI styled**: Matches the rest of our app without extra work.\n\n## What to Watch Out For\n\n**Don't spam toasts**: In loops or rapid-fire operations, you'll get 50 toasts. Be smart about when you call it.\n\n**Server components**: The toast utility itself is client-side. You can call it from server actions, but not server components directly.\n\n**Loading toasts**: Always dismiss them. I've left loading toasts up by accident more times than I want to admit.\n\n## Wrapping Up\n\nThis setup has saved me so much time. No more:\n- \"How do I show a toast from this random utility?\"\n- \"Do I need to pass the toast function through props?\"\n- \"Why isn't the toast context working here?\"\n\nJust import it, call it, done.\n\nIf you're still using some complicated toast setup with providers and contexts, try this instead. Way simpler."
  }
]